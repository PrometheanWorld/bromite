From 5d8ceb69edf1a4c1abef897994ea113cf9d0a9e5 Mon Sep 17 00:00:00 2001
From: DavidDing <davidding@nd.com.cn>
Date: Wed, 7 Dec 2022 16:04:15 +0800
Subject: [PATCH] AP9-10449 AP9 - Camera not detected in Chromium browser for
 Google Meet

Fix version = 1.2.1

Why:
There is a big difference between the USB camera connected in the user scenario of the ActivPanel and the embedded camera in the mobile phone.
For some outdated or low-tier USB cameras, valid parameters cannot be obtained through the CameraCharacteristics object, including REQUEST_AVAILABLE_CAPABILITIES, SCALER_STREAM_CONFIGURATION_MAP, and so on.
If we still try to invoke the NULL object after getting it through CameraCharacteristics, the Null-pointer exception will be produced, causing Chromium to crash.

How:
In VideoCaptureCamera2, add a non-NULL judgment before getting related properties through CameraCharacteristics and trying to invoke them.
---
 .../chromium/media/VideoCaptureCamera2.java   | 215 ++++++++++--------
 1 file changed, 115 insertions(+), 100 deletions(-)

diff --git a/media/capture/video/android/java/src/org/chromium/media/VideoCaptureCamera2.java b/media/capture/video/android/java/src/org/chromium/media/VideoCaptureCamera2.java
index 125e801d1902e..96980f99e0190 100644
--- a/media/capture/video/android/java/src/org/chromium/media/VideoCaptureCamera2.java
+++ b/media/capture/video/android/java/src/org/chromium/media/VideoCaptureCamera2.java
@@ -482,28 +482,29 @@ public class VideoCaptureCamera2 extends VideoCapture {
             } else { //  null value
                 Log.d(TAG, "LENS_FOCUS_DISTANCE is null");
             }
-
-            for (int mode : jniFocusModes) {
-                if (mode == CameraMetadata.CONTROL_AF_MODE_OFF) {
-                    focusModes.add(Integer.valueOf(AndroidMeteringMode.FIXED));
-                    // Smallest step by which focus distance can be changed. This value is not
-                    // exposed by Android.
-                    float mStepFocusDistance = 0.01f;
-                    builder.setDouble(PhotoCapabilityDouble.MIN_FOCUS_DISTANCE, minFocusDistance)
-                            .setDouble(PhotoCapabilityDouble.MAX_FOCUS_DISTANCE, maxFocusDistance)
-                            .setDouble(
-                                    PhotoCapabilityDouble.STEP_FOCUS_DISTANCE, mStepFocusDistance);
-                } else if (mode == CameraMetadata.CONTROL_AF_MODE_AUTO
-                        || mode == CameraMetadata.CONTROL_AF_MODE_MACRO) {
-                    // CONTROL_AF_MODE_{AUTO,MACRO} do not imply continuously focusing.
-                    if (!focusModes.contains(Integer.valueOf(AndroidMeteringMode.SINGLE_SHOT))) {
-                        focusModes.add(Integer.valueOf(AndroidMeteringMode.SINGLE_SHOT));
-                    }
-                } else if (mode == CameraMetadata.CONTROL_AF_MODE_CONTINUOUS_VIDEO
-                        || mode == CameraMetadata.CONTROL_AF_MODE_CONTINUOUS_PICTURE
-                        || mode == CameraMetadata.CONTROL_AF_MODE_EDOF) {
-                    if (!focusModes.contains(Integer.valueOf(AndroidMeteringMode.CONTINUOUS))) {
-                        focusModes.add(Integer.valueOf(AndroidMeteringMode.CONTINUOUS));
+            if (jniFocusModes != null && jniFocusModes.length > 0) {
+                for (int mode : jniFocusModes) {
+                    if (mode == CameraMetadata.CONTROL_AF_MODE_OFF) {
+                        focusModes.add(Integer.valueOf(AndroidMeteringMode.FIXED));
+                        // Smallest step by which focus distance can be changed. This value is not
+                        // exposed by Android.
+                        float mStepFocusDistance = 0.01f;
+                        builder.setDouble(PhotoCapabilityDouble.MIN_FOCUS_DISTANCE, minFocusDistance)
+                                .setDouble(PhotoCapabilityDouble.MAX_FOCUS_DISTANCE, maxFocusDistance)
+                                .setDouble(
+                                        PhotoCapabilityDouble.STEP_FOCUS_DISTANCE, mStepFocusDistance);
+                    } else if (mode == CameraMetadata.CONTROL_AF_MODE_AUTO
+                            || mode == CameraMetadata.CONTROL_AF_MODE_MACRO) {
+                        // CONTROL_AF_MODE_{AUTO,MACRO} do not imply continuously focusing.
+                        if (!focusModes.contains(Integer.valueOf(AndroidMeteringMode.SINGLE_SHOT))) {
+                            focusModes.add(Integer.valueOf(AndroidMeteringMode.SINGLE_SHOT));
+                        }
+                    } else if (mode == CameraMetadata.CONTROL_AF_MODE_CONTINUOUS_VIDEO
+                            || mode == CameraMetadata.CONTROL_AF_MODE_CONTINUOUS_PICTURE
+                            || mode == CameraMetadata.CONTROL_AF_MODE_EDOF) {
+                        if (!focusModes.contains(Integer.valueOf(AndroidMeteringMode.CONTINUOUS))) {
+                            focusModes.add(Integer.valueOf(AndroidMeteringMode.CONTINUOUS));
+                        }
                     }
                 }
             }
@@ -538,43 +539,45 @@ public class VideoCaptureCamera2 extends VideoCapture {
             final int[] jniExposureModes =
                     cameraCharacteristics.get(CameraCharacteristics.CONTROL_AE_AVAILABLE_MODES);
             ArrayList<Integer> exposureModes = new ArrayList<Integer>(1);
-            for (int mode : jniExposureModes) {
-                if (mode == CameraMetadata.CONTROL_AE_MODE_ON
-                        || mode == CameraMetadata.CONTROL_AE_MODE_ON_AUTO_FLASH
-                        || mode == CameraMetadata.CONTROL_AE_MODE_ON_ALWAYS_FLASH
-                        || mode == CameraMetadata.CONTROL_AE_MODE_ON_AUTO_FLASH_REDEYE) {
-                    exposureModes.add(Integer.valueOf(AndroidMeteringMode.CONTINUOUS));
-                    break;
-                } else {
-                    // Exposure mode is Manual. Here we can set exposure time.
-                    // All exposure time values from Android are in nano seconds.
-                    // Spec (https://w3c.github.io/mediacapture-image/#exposure-time)
-                    // expects exposureTime to be in 100 microsecond units.
-                    // A value of 1.0 means an exposure time of 1/10000th of a second
-                    // and a value of 10000.0 means an exposure time of 1 second.
-                    if (cameraCharacteristics.get(
-                                CameraCharacteristics.SENSOR_INFO_EXPOSURE_TIME_RANGE)
-                            != null) {
-                        // The minimum exposure time will be less than 100 micro-seconds.
-                        // For FULL capability devices (android.info.supportedHardwareLevel ==
-                        // FULL), the maximum exposure time will be greater than 100 millisecond.
-                        Range<Long> range = cameraCharacteristics.get(
-                                CameraCharacteristics.SENSOR_INFO_EXPOSURE_TIME_RANGE);
-                        final long minExposureTime = range.getLower();
-                        final long maxExposureTime = range.getUpper();
-
-                        if (minExposureTime != 0 && maxExposureTime != 0) {
-                            builder.setDouble(PhotoCapabilityDouble.MAX_EXPOSURE_TIME,
-                                           maxExposureTime / kNanosecondsPer100Microsecond)
-                                    .setDouble(PhotoCapabilityDouble.MIN_EXPOSURE_TIME,
-                                            minExposureTime / kNanosecondsPer100Microsecond);
+            if (jniExposureModes != null && jniExposureModes.length > 0) {
+                for (int mode : jniExposureModes) {
+                    if (mode == CameraMetadata.CONTROL_AE_MODE_ON
+                            || mode == CameraMetadata.CONTROL_AE_MODE_ON_AUTO_FLASH
+                            || mode == CameraMetadata.CONTROL_AE_MODE_ON_ALWAYS_FLASH
+                            || mode == CameraMetadata.CONTROL_AE_MODE_ON_AUTO_FLASH_REDEYE) {
+                        exposureModes.add(Integer.valueOf(AndroidMeteringMode.CONTINUOUS));
+                        break;
+                    } else {
+                        // Exposure mode is Manual. Here we can set exposure time.
+                        // All exposure time values from Android are in nano seconds.
+                        // Spec (https://w3c.github.io/mediacapture-image/#exposure-time)
+                        // expects exposureTime to be in 100 microsecond units.
+                        // A value of 1.0 means an exposure time of 1/10000th of a second
+                        // and a value of 10000.0 means an exposure time of 1 second.
+                        if (cameraCharacteristics.get(
+                                    CameraCharacteristics.SENSOR_INFO_EXPOSURE_TIME_RANGE)
+                                != null) {
+                            // The minimum exposure time will be less than 100 micro-seconds.
+                            // For FULL capability devices (android.info.supportedHardwareLevel ==
+                            // FULL), the maximum exposure time will be greater than 100 millisecond.
+                            Range<Long> range = cameraCharacteristics.get(
+                                    CameraCharacteristics.SENSOR_INFO_EXPOSURE_TIME_RANGE);
+                            final long minExposureTime = range.getLower();
+                            final long maxExposureTime = range.getUpper();
+    
+                            if (minExposureTime != 0 && maxExposureTime != 0) {
+                                builder.setDouble(PhotoCapabilityDouble.MAX_EXPOSURE_TIME,
+                                               maxExposureTime / kNanosecondsPer100Microsecond)
+                                        .setDouble(PhotoCapabilityDouble.MIN_EXPOSURE_TIME,
+                                                minExposureTime / kNanosecondsPer100Microsecond);
+                            }
+                            // Smallest step by which exposure time can be changed. This value is not
+                            // exposed by Android.
+                            builder.setDouble(PhotoCapabilityDouble.STEP_EXPOSURE_TIME,
+                                           10000 / kNanosecondsPer100Microsecond)
+                                    .setDouble(PhotoCapabilityDouble.CURRENT_EXPOSURE_TIME,
+                                            mLastExposureTimeNs / kNanosecondsPer100Microsecond);
                         }
-                        // Smallest step by which exposure time can be changed. This value is not
-                        // exposed by Android.
-                        builder.setDouble(PhotoCapabilityDouble.STEP_EXPOSURE_TIME,
-                                       10000 / kNanosecondsPer100Microsecond)
-                                .setDouble(PhotoCapabilityDouble.CURRENT_EXPOSURE_TIME,
-                                        mLastExposureTimeNs / kNanosecondsPer100Microsecond);
                     }
                 }
             }
@@ -621,10 +624,12 @@ public class VideoCaptureCamera2 extends VideoCapture {
             final int[] jniWhiteBalanceMode =
                     cameraCharacteristics.get(CameraCharacteristics.CONTROL_AWB_AVAILABLE_MODES);
             ArrayList<Integer> whiteBalanceModes = new ArrayList<Integer>(1);
-            for (int mode : jniWhiteBalanceMode) {
-                if (mode == CameraMetadata.CONTROL_AWB_MODE_AUTO) {
-                    whiteBalanceModes.add(Integer.valueOf(AndroidMeteringMode.CONTINUOUS));
-                    break;
+            if (jniWhiteBalanceMode != null && jniWhiteBalanceMode.length > 0) {
+                for (int mode : jniWhiteBalanceMode) {
+                    if (mode == CameraMetadata.CONTROL_AWB_MODE_AUTO) {
+                        whiteBalanceModes.add(Integer.valueOf(AndroidMeteringMode.CONTINUOUS));
+                        break;
+                    }
                 }
             }
             try {
@@ -681,13 +686,15 @@ public class VideoCaptureCamera2 extends VideoCapture {
                 final int[] flashModes =
                         cameraCharacteristics.get(CameraCharacteristics.CONTROL_AE_AVAILABLE_MODES);
                 ArrayList<Integer> modes = new ArrayList<Integer>(0);
-                for (int flashMode : flashModes) {
-                    if (flashMode == CameraMetadata.FLASH_MODE_OFF) {
-                        modes.add(Integer.valueOf(AndroidFillLightMode.OFF));
-                    } else if (flashMode == CameraMetadata.CONTROL_AE_MODE_ON_AUTO_FLASH) {
-                        modes.add(Integer.valueOf(AndroidFillLightMode.AUTO));
-                    } else if (flashMode == CameraMetadata.CONTROL_AE_MODE_ON_ALWAYS_FLASH) {
-                        modes.add(Integer.valueOf(AndroidFillLightMode.FLASH));
+                if (flashModes != null && flashModes.length > 0) {
+                    for (int flashMode : flashModes) {
+                        if (flashMode == CameraMetadata.FLASH_MODE_OFF) {
+                            modes.add(Integer.valueOf(AndroidFillLightMode.OFF));
+                        } else if (flashMode == CameraMetadata.CONTROL_AE_MODE_ON_AUTO_FLASH) {
+                            modes.add(Integer.valueOf(AndroidFillLightMode.AUTO));
+                        } else if (flashMode == CameraMetadata.CONTROL_AE_MODE_ON_ALWAYS_FLASH) {
+                            modes.add(Integer.valueOf(AndroidFillLightMode.FLASH));
+                        }
                     }
                 }
                 builder.setFillLightModeArray(integerArrayListToArray(modes));
@@ -1107,11 +1114,13 @@ public class VideoCaptureCamera2 extends VideoCapture {
             if (cameraCharacteristics == null) return false;
             final int[] stabilizationModes = cameraCharacteristics.get(
                     CameraCharacteristics.CONTROL_AVAILABLE_VIDEO_STABILIZATION_MODES);
-            for (int mode : stabilizationModes) {
-                if (mode == CameraMetadata.CONTROL_VIDEO_STABILIZATION_MODE_ON) {
-                    mPreviewRequestBuilder.set(CaptureRequest.CONTROL_VIDEO_STABILIZATION_MODE,
-                            CameraMetadata.CONTROL_VIDEO_STABILIZATION_MODE_ON);
-                    break;
+            if (stabilizationModes != null && stabilizationModes.length > 0) {
+                for (int mode : stabilizationModes) {
+                    if (mode == CameraMetadata.CONTROL_VIDEO_STABILIZATION_MODE_ON) {
+                        mPreviewRequestBuilder.set(CaptureRequest.CONTROL_VIDEO_STABILIZATION_MODE,
+                                CameraMetadata.CONTROL_VIDEO_STABILIZATION_MODE_ON);
+                        break;
+                    }
                 }
             }
 
@@ -1380,10 +1389,12 @@ public class VideoCaptureCamera2 extends VideoCapture {
         final int[] capabilities =
                 cameraCharacteristics.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);
         boolean backwardCompatible = false;
-        for (int cap : capabilities) {
-            if (cap == CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_BACKWARD_COMPATIBLE) {
-                backwardCompatible = true;
-                break;
+        if (capabilities != null && capabilities.length > 0) {
+            for (int cap : capabilities) {
+                if (cap == CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_BACKWARD_COMPATIBLE) {
+                    backwardCompatible = true;
+                    break;
+                }
             }
         }
         if (!backwardCompatible) {
@@ -1513,35 +1524,39 @@ public class VideoCaptureCamera2 extends VideoCapture {
             // Per-format frame rate via getOutputMinFrameDuration() is only available if the
             // property REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR is set.
             boolean minFrameDurationAvailable = false;
-            for (int cap : capabilities) {
-                if (cap == CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR) {
-                    minFrameDurationAvailable = true;
-                    break;
+            if (capabilities != null && capabilities.length > 0) {
+                for (int cap : capabilities) {
+                    if (cap == CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR) {
+                        minFrameDurationAvailable = true;
+                        break;
+                    }
                 }
             }
 
             ArrayList<VideoCaptureFormat> formatList = new ArrayList<VideoCaptureFormat>();
             final StreamConfigurationMap streamMap = cameraCharacteristics.get(
                     CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
-            final int[] formats = streamMap.getOutputFormats();
-            for (int format : formats) {
-                final Size[] sizes = streamMap.getOutputSizes(format);
-                if (sizes == null) continue;
-                for (Size size : sizes) {
-                    double minFrameRate = 0.0f;
-                    if (minFrameDurationAvailable) {
-                        final long minFrameDurationInNanoseconds =
-                                streamMap.getOutputMinFrameDuration(format, size);
-                        minFrameRate = (minFrameDurationInNanoseconds == 0)
-                                ? 0.0f
-                                : (kNanosecondsPerSecond / minFrameDurationInNanoseconds);
-                    } else {
-                        // TODO(mcasas): find out where to get the info from in this case.
-                        // Hint: perhaps using SCALER_AVAILABLE_PROCESSED_MIN_DURATIONS.
-                        minFrameRate = 0.0;
+            if (streamMap != null) {
+                final int[] formats = streamMap.getOutputFormats();
+                for (int format : formats) {
+                    final Size[] sizes = streamMap.getOutputSizes(format);
+                    if (sizes == null) continue;
+                    for (Size size : sizes) {
+                        double minFrameRate = 0.0f;
+                        if (minFrameDurationAvailable) {
+                            final long minFrameDurationInNanoseconds =
+                                    streamMap.getOutputMinFrameDuration(format, size);
+                            minFrameRate = (minFrameDurationInNanoseconds == 0)
+                                    ? 0.0f
+                                    : (kNanosecondsPerSecond / minFrameDurationInNanoseconds);
+                        } else {
+                            // TODO(mcasas): find out where to get the info from in this case.
+                            // Hint: perhaps using SCALER_AVAILABLE_PROCESSED_MIN_DURATIONS.
+                            minFrameRate = 0.0;
+                        }
+                        formatList.add(new VideoCaptureFormat(
+                                size.getWidth(), size.getHeight(), (int) minFrameRate, format));
                     }
-                    formatList.add(new VideoCaptureFormat(
-                            size.getWidth(), size.getHeight(), (int) minFrameRate, format));
                 }
             }
             return formatList.toArray(new VideoCaptureFormat[formatList.size()]);
-- 
2.34.1

